---
title: ComputerNetworkNotes
date: 2019-01-17 20:07:52
tags: notes
index_img: http://cdn.pfish.xyz/pic/20190117/5UStVDr4aF58.png?imageslim
banner_img: http://cdn.pfish.xyz/pic/20190117/5UStVDr4aF58.png
---

本篇用来记一些计算机网络相关的笔记，主要是针对学过的进行巩固，以及总结一些可能会用到的知识点。
<!--more-->

### TCP与UDP
#### TCP 

> TCP (Transmission Contorl Protocol) 传输控制协议: 是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。

两个使用TCP的应用在传输数据前必须建立一个TCP连接，然后通过这个连接彼此通信。

TCP通过三次握手创建连接，四次挥手终止连接。是面向连接的、可靠的传输。应用了许多重要机制保证可靠：

 - 使用序号对接收的报文进行排序和检验重复的数据。
 - 使用校验和检测报文段的错误。
 - 使用确认和计时器来检测和纠正丢包或延时。
 - 流控制、拥塞控制、丢包重传等。

TCP 支持的应用有：Telnet、FTP、SMTP等。

#### UDP
>UDP(User Datagram Protocol) 用户数据报协议:又称用户数据包协议，是一个简单的面向数据报的传输层协议。该协议由 David P. Reed 在 1980 年设计且在RFC 768中被规范。 

TCP 是面向连接、可靠的，UDP是非面向连接、不可靠的。如图

<img src="http://cdn.pfish.xyz/pic/20190117/8HIzeGwMSOEF.png?imageslim" width="100%">

>上课的时候被UDP的头部（TCP也一样）弄得很懵，以后有空搞懂了再来补充把

UDP一般允许一定量的丢包、出错和复制粘贴。但有些应用有需要的话会在应用层增加根本的可靠机制。类似如今的直播、视频点播、游戏和网络电话等大部分都是典型的UDP应用。

由于缺乏像TCP一样的拥塞控制，UDP发送者是不能够监测拥塞的。

使用UDP协议的一些应用有：DNS、(简单网络管理协议)SNMP、DHCP、RIP等。

### HTTP与HTTPS
#### HTTP
> HTTP(Hyper Text Transport Protocol) 超文本传输协议，HTTP是万维网的数据通信的基础。

一般用来发布和请求由统一资源定位符(URL)标识的资源，默认端口80，HTTP1.1协议中定义了八种方法(动作)来操作指定的资源：
- **GET**
向指定资源发出“显示”请求，读取数据，是幂等操作。
- **POST**
向指定资源提交数据，请求服务器处理。非幂等操作。
- **PUT**
与POST差不多，一般用于更新资源。
- **DELETE**
请求服务器删除Request-URL所标识的资源。
- **HEAD**
与GET方法一样，请求指定资源。只不过服务器不返回资源的文本部分。
- **TRACE**
回显服务器收到的请求，主要用于诊断或测试。
- **OPTIONS**
使服务器传回该资源所支持的所有HTTP请求方法。
- **PATCH**
将局部修改应用到资源
- **CONNECT**
HTTP1.1协议中预留的，将连接改为管道方式的代理服务器。通常用于ssl连接


#### HTTPS
> HTTPS 与 HTTP 并不是两种完全不同的协议，HTTPS是在HTTP上加了一层SSL使得连接更加的安全。

HTTPS协议主要作用可分为两种：
- 一种是建立一个信息安全通道，来保证数据传输的安全；
- 另一种就是确认网站的真实性。

使用HTTPS需要CA证书，现在注册个人域名一般都能免费申请。

现在HTTPS已经成为很普及的技术了，苹果的App Store以及PWA(Progressive Web App)和微信小程序等都要求开发者必须使用HTTPS。

##### HTTPS的缺点
 1. 握手协议阶段花费时间比HTTP长。
 2. SSL证书的成本比较高。
 3. 并不是绝对安全，加密范围有限。


### 从输入网址到显示网页这中间发生了什么？

#### 输入网址
检测是否为合法url,格式是否正确
#### 查询DNS
先从本地DNS缓存查询是否有域名对应的IP，有则使用，没有就向上级DNS服务器发起请求，找不到则继续往上级查询，直至根域名服务器，找到对应的IP。
#### 连接网站服务器
##### 建立TCP连接
利用三次握手建立一个TCP连接。

##### HTTP请求
然后根据网址开头的HTTP、HTTPS等协议的不同，请求该IP所对应服务器的不同端口（分别为80、443）

#### 服务器处理请求
以上步骤顺利都进行后，服务器会接收到HTTP请求，然后将收到的HTTP报文封装成HTTP Request对象，再进一步交给WEB服务器（Nginx，Tomcat，uwsgi等）处理
，处理完的结果以HTTP Response对象返回，主要包括：响应头、状态码、响应报文三个部分。

#### 浏览器处理响应
当浏览器接收到服务器的响应后，会根据状态码做一个判断，
状态码主要包括以下部分：
1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接受。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务器端错误–服务器未能实现合法的请求。

并拿到返回的数据。

##### 页面渲染
这一步也是包含在浏览器处理中，当响应的内容是一个HTTP文档时，就开始解析并渲染页面（这一步涉及前端知识很多，不详细说了），当遇到一些外链，如图片，JS文件等，继续重复请求上几步过程下载资源。

#### 断开连接或继续保持
当请求完成，会根据不同情况使用四次挥手断开连接或者继续保持连接。

### Session、Cookies
#### Session
> 会话（Session）是用来跟踪用户的整个会话的一种技术。通过在服务端记录客户端状态。

当客户端访问服务器的时候，服务端把客户端信息以某种形式记录在服务器上，这就是Session。当客户端再次访问时只需要从该Session中查找该客户的状态就可以了。

Java Servlet 通过request.getSession()方法获得客户的Session:

 ```Java
// 获得一个Session对象
HttpSession session = request.getSession();
// 设置Session中的属性
session.setAttribute("loginTime", new Date())
// 获得Session中的属性
Date loginTime = (Date)session.getAttribute("loginTime")
 ```

通过Session可以唯一确定一个用户，各客户端的Session也彼此独立，互不可见。这样服务端和客户端就能安全的交流。

#### Cookies
> Cookies意为“甜饼”、“曲奇”，它通过在客户端记录信息确定用户的身份。

HTTP协议是无状态的，为了弥补这个不足，在Session出现之前，网站几乎都是用Cookies来跟踪会话。

就是每个客户端保存一个通行证，当访问服务端时带上这个通行证，服务端就能确定客户身份了。

在浏览器地址栏输入：
 ```JavaScript
 javascript: alert(doucument.cookie)
 ```
就能查看本网站颁发的所有Cookie的内容。

例如在爬虫程序的开发里，就会遇到登录并需要保持一个Cookies的情况。这时候利用requests库的Session对象能够帮助我们在跨请求操作时保持某些参数。

 ```Python
s = requests.Session()
# 请求参数
req_param = {
      'username': 'pengyu',
      'password': 'pwd123'
      }
s.post("http://www.webpage.com/login", json=json.loads(req_param))
# 通过保持的Cookies信息达到跨请求操作的目的
response = s.get("http://www.webpage.com/info")
 ```

#### Session与Cookies的不同

||Session|Cookies|
|-|-|-|
|保存位置|服务端|客户端|
|隐私策略|较为安全|不安全|
|长度限制|无限制|有限制|

### OSI网络结构与TCP/IP

#### OSI 七层模型
|OSI参考模型|各层解释|TCP/IP|
|:-:|:-:|:-:|
|应用层|为应用层提供服务|
|表示层|数据格式转换，数据加密|
|会话层|建立、管理和维护会话|应用层|
|传输层|建立、管理和维护端到端的连接|传输层|
|网络层|IP选址及路由选择|网络层|
|数据链路层|提供介质访问和链路管理|数据链路层|
|物理层|物理层|物理层|


#### TCP/IP协议

|TCP/IP五层模型|协议|
|:-:|:-:|
|应用层|HTTP、FTP、Telnet、TFTP、DNS、SMTP|
|传输层|TCP、UDP|
|网络层|IP、ICMP、RIP、IGMP|
|数据链路层|ARP、RAPP、CSMD/CD、PPP|
|物理层|FE自协商、Manchester、MLT-3|



### 握手与挥手

#### 三次握手
 **握手只能由客户端发起，三次握手用以同步客户端和服务端的序列号和确认号，并交换TCP窗口大小信息。**

**1. 客户端发送一个带SYN=1，Seq=X的数据包到服务器端口。**
（第一次握手由客户端发起，告诉服务器，我要发送请求了）
**2. 服务器收到客户端发来的第一个数据包后，回一个带SYN=1，ACK=X+1，Seq=Y的响应包以传达确认信息。**
（第二次握手由服务端发起，告诉客户端，我准备好了，你赶紧发送吧。）
**3. 客户端收到服务端的响应包后，回传一个带ACK=Y+1，Seq=Z的数据包，代表握手结束，TCP连接建立。**
（第三次握手由客户端发送，告诉服务端，我马上发送了，准备接收吧。）

##### 为什么需要三次握手
> 谢希仁《计算机网络》中提到：“是为了防止已失效的连接请求报文段突然又传送到服务端，产生错误”

**因为在现实网络环境并不是那么理想，客户端或服务端发送的报文都可能会在网络某处中阻塞导致延迟到达，而如果此时服务器还认为这是一次连接请求，那么就会导致一直等待客户端发送下一次请求，从而影响服务器的性能**

#### 四次挥手
